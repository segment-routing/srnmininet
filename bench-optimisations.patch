diff --git a/sigcomm/sdnres-sigcomm/lib/Makefile b/sigcomm/sdnres-sigcomm/lib/Makefile
index 0482d39..07db47c 100644
--- a/sigcomm/sdnres-sigcomm/lib/Makefile
+++ b/sigcomm/sdnres-sigcomm/lib/Makefile
@@ -1,6 +1,6 @@
 CC=gcc
 AR=ar
-CFLAGS=-g -Wall -W -O0
+CFLAGS=-g -Wall -W -O2
 CFLAGS += -I./c-ares
 SRC=arraylist.c hashmap.c lpm.c misc.c mq.c srdb.c srdns.c
 OBJ=$(SRC:.c=.o)
diff --git a/sigcomm/sdnres-sigcomm/lib/hashmap.c b/sigcomm/sdnres-sigcomm/lib/hashmap.c
index 3a214bd..14ef3e8 100644
--- a/sigcomm/sdnres-sigcomm/lib/hashmap.c
+++ b/sigcomm/sdnres-sigcomm/lib/hashmap.c
@@ -5,6 +5,8 @@
 
 #include "hashmap.h"
 
+#define my_alist_elem(al, idx) ((al)->data + ((idx) << 3))
+
 struct hashmap *hmap_new(unsigned int (*hash)(void *key),
 			 int (*compare)(void *k1, void *k2))
 {
@@ -36,6 +38,33 @@ void hmap_destroy(struct hashmap *hm)
 	free(hm);
 }
 
+struct hashmap *hmap_copy(struct hashmap *hm)
+{
+	struct hashmap *nhm;
+	int i;
+
+	nhm = malloc(sizeof(*nhm));
+	if (!nhm)
+		return NULL;
+
+	nhm->size = hm->size;
+	nhm->hash = hm->hash;
+	nhm->compare = hm->compare;
+
+	nhm->map = malloc(hm->size * sizeof(struct arraylist *));
+	memset(nhm->map, 0, hm->size * sizeof(struct arraylist *));
+	for (i = 0; i < hm->size; i++) {
+		if (hm->map[i])
+			nhm->map[i] = alist_copy(hm->map[i]);
+	}
+
+	nhm->keys = alist_copy(hm->keys);
+
+	pthread_rwlock_init(&nhm->lock, NULL);
+
+	return nhm;
+}
+
 int hmap_hash(struct hashmap *hm, void *key)
 {
 	return hm->hash(key) % hm->size;
@@ -47,7 +76,8 @@ bool hmap_key_exist(struct hashmap *hm, void *key)
 	unsigned int i;
 
 	for (i = 0; i < hm->keys->elem_count; i++) {
-		alist_get(hm->keys, i, &k);
+		k = *(struct key **)my_alist_elem(hm->keys, i);
+//		alist_get(hm->keys, i, &k);
 		if (hm->compare(k, key) == 0)
 			return true;
 	}
diff --git a/sigcomm/sdnres-sigcomm/lib/hashmap.h b/sigcomm/sdnres-sigcomm/lib/hashmap.h
index 44382ab..b43d3ed 100644
--- a/sigcomm/sdnres-sigcomm/lib/hashmap.h
+++ b/sigcomm/sdnres-sigcomm/lib/hashmap.h
@@ -34,6 +34,7 @@ void *hmap_get(struct hashmap *hm, void *key);
 int hmap_delete(struct hashmap *hm, void *key);
 bool hmap_key_exist(struct hashmap *hm, void *key);
 void hmap_flush(struct hashmap *hm);
+struct hashmap *hmap_copy(struct hashmap *hm);
 
 static inline void hmap_read_lock(struct hashmap *hm)
 {
diff --git a/sigcomm/sdnres-sigcomm/sr-ctrl/Makefile b/sigcomm/sdnres-sigcomm/sr-ctrl/Makefile
index 76bb352..d6e9100 100644
--- a/sigcomm/sdnres-sigcomm/sr-ctrl/Makefile
+++ b/sigcomm/sdnres-sigcomm/sr-ctrl/Makefile
@@ -1,5 +1,5 @@
 CC=gcc
-CFLAGS=-g -Wall -W -O0 -I../lib
+CFLAGS=-g -Wall -W -O2 -I../lib
 LDFLAGS=-L../lib -lsr -pthread
 SRC=graph.c rules.c sr-ctrl.c
 OBJ=$(SRC:.c=.o)
diff --git a/sigcomm/sdnres-sigcomm/sr-ctrl/graph.c b/sigcomm/sdnres-sigcomm/sr-ctrl/graph.c
index c99da46..43120a7 100644
--- a/sigcomm/sdnres-sigcomm/sr-ctrl/graph.c
+++ b/sigcomm/sdnres-sigcomm/sr-ctrl/graph.c
@@ -9,6 +9,24 @@
 #include "graph.h"
 #include "misc.h"
 
+#define my_alist_elem(al, idx) ((al)->data + ((idx) << 3))
+
+int dj_cnt;
+
+static bool my_alist_exist(struct arraylist *al, void *elem)
+{
+	unsigned int i;
+	void **entry;
+
+	for (i = 0; i < al->elem_count; i++) {
+		entry = my_alist_elem(al, i);
+		if (*entry == *(void **)elem)
+			return true;
+	}
+
+	return false;
+}
+
 static unsigned int hash_nodepair(void *key)
 {
 	struct nodepair *p = key;
@@ -72,6 +90,8 @@ struct graph *graph_new(void)
 		return NULL;
 	}
 
+	g->dcache = hmap_new(hash_node, compare_node);
+
 	pthread_rwlock_init(&g->lock, NULL);
 
 	g->dirty = true;
@@ -94,6 +114,7 @@ void graph_destroy(struct graph *g, bool shallow)
 
 	hmap_destroy(g->min_edges);
 	hmap_destroy(g->neighs);
+	hmap_destroy(g->dcache);
 
 	while (g->edges->elem_count) {
 		alist_get(g->edges, 0, &e);
@@ -258,7 +279,8 @@ static struct edge *graph_get_minimal_edge(struct graph *g, struct node *local,
 	unsigned int i;
 
 	for (i = 0; i < g->edges->elem_count; i++) {
-		alist_get(g->edges, i, &edge);
+		edge = *(struct edge **)my_alist_elem(g->edges, i);
+//		alist_get(g->edges, i, &edge);
 
 		if (edge->local->id != local->id ||
 		    edge->remote->id != remote->id)
@@ -282,11 +304,13 @@ void graph_compute_minimal_edges(struct graph *g)
 	hmap_flush(g->min_edges);
 
 	for (i = 0; i < g->nodes->elem_count; i++) {
-		alist_get(g->nodes, i, &node1);
+//		alist_get(g->nodes, i, &node1);
+		node1 = *(struct node **)my_alist_elem(g->nodes, i);
 		for (j = 0; j < g->nodes->elem_count; j++) {
 			if (i == j)
 				continue;
-			alist_get(g->nodes, j, &node2);
+//			alist_get(g->nodes, j, &node2);
+			node2 = *(struct node **)my_alist_elem(g->nodes, j);
 			edge = graph_get_minimal_edge(g, node1, node2);
 			if (!edge)
 				continue;
@@ -312,7 +336,7 @@ static struct arraylist *graph_compute_neighbors(struct graph *g,
 		if (edge->local->id != node->id)
 			continue;
 
-		if (alist_exist(neighs, &edge->remote))
+		if (my_alist_exist(neighs, &edge->remote))
 			continue;
 
 		alist_insert(neighs, &edge->remote);
@@ -357,6 +381,13 @@ struct graph *graph_clone(struct graph *g)
 	alist_append(g_clone->nodes, g->nodes);
 	alist_append(g_clone->edges, g->edges);
 
+	hmap_destroy(g_clone->min_edges);
+	g_clone->min_edges = hmap_copy(g->min_edges);
+
+	graph_compute_all_neighbors(g_clone);
+
+	g_clone->dirty = g->dirty;
+
 	return g_clone;
 }
 
@@ -493,7 +524,7 @@ static void __graph_dijkstra(struct graph *g, struct node *src,
 			struct nodepair pair;
 
 			alist_get(neighs, i, &v);
-			if (!alist_exist(Q, &v))
+			if (!my_alist_exist(Q, &v))
 				continue;
 
 			pair.local = backward ? v : u;
@@ -529,6 +560,7 @@ static void __graph_dijkstra(struct graph *g, struct node *src,
 
 void graph_dijkstra(struct graph *g, struct node *src, struct dres *res)
 {
+	dj_cnt++;
 	__graph_dijkstra(g, src, res, false);
 }
 
@@ -555,6 +587,21 @@ void graph_dijkstra_free(struct dres *res)
 	hmap_destroy(res->dist);
 }
 
+void graph_cache_dijkstra(struct graph *g)
+{
+	struct node *node;
+	struct dres *gres;
+	unsigned int i;
+
+	for (i = 0; i < g->nodes->elem_count; i++) {
+		alist_get(g->nodes, i, &node);
+
+		gres = malloc(sizeof(*gres));
+		graph_dijkstra(g, node, gres);
+		hmap_set(g->dcache, node, gres);
+	}
+}
+
 int graph_prune(struct graph *g, bool (*prune)(struct edge *e, void *arg),
 		void *_arg)
 {
@@ -609,6 +656,7 @@ int graph_minseg(struct graph *g, struct arraylist *path,
 {
 	struct node *node_r, *node_i, *node_ii;
 	struct dres res_r, res_i;
+	struct dres *dres_r, *dres_i;
 	unsigned int i, r;
 
 	if (!path->elem_count)
@@ -624,11 +672,23 @@ int graph_minseg(struct graph *g, struct arraylist *path,
 		alist_get(path, i + 1, &node_ii);
 		alist_get(path, r, &node_r);
 
-		graph_dijkstra(g, node_i, &res_i);
-		graph_dijkstra(g, node_r, &res_r);
+		dres_i = hmap_get(g->dcache, node_i);
+		dres_r = hmap_get(g->dcache, node_r);
+
+		if (dres_i) {
+			res_i = *dres_i;
+			dj_cnt++;
+		} else
+			graph_dijkstra(g, node_i, &res_i);
+
+		if (dres_r) {
+			res_r = *dres_r;
+			dj_cnt++;
+		} else
+			graph_dijkstra(g, node_r, &res_r);
 
 		prev = hmap_get(res_r.prev, node_ii);
-		if (!alist_exist(prev, &node_i)) { /* MinSegECMP:4 */
+		if (!my_alist_exist(prev, &node_i)) { /* MinSegECMP:4 */
 			prev = hmap_get(res_i.prev, node_ii);
 			if (prev->elem_count == 1) { /* MinSegECMP:5 */
 				insert_node_segment(node_i, res);
@@ -659,8 +719,10 @@ int graph_minseg(struct graph *g, struct arraylist *path,
 		}
 
 next_free:
-		graph_dijkstra_free(&res_i);
-		graph_dijkstra_free(&res_r);
+		if (!dres_i)
+			graph_dijkstra_free(&res_i);
+		if (!dres_r)
+			graph_dijkstra_free(&res_r);
 	}
 
 	return 0;
diff --git a/sigcomm/sdnres-sigcomm/sr-ctrl/graph.h b/sigcomm/sdnres-sigcomm/sr-ctrl/graph.h
index 148f5db..8989393 100644
--- a/sigcomm/sdnres-sigcomm/sr-ctrl/graph.h
+++ b/sigcomm/sdnres-sigcomm/sr-ctrl/graph.h
@@ -44,6 +44,7 @@ struct graph {
 	unsigned int last_edge;
 	struct hashmap *min_edges;
 	struct hashmap *neighs;
+	struct hashmap *dcache;
 	pthread_rwlock_t lock;
 	bool dirty;
 };
@@ -72,6 +73,7 @@ int graph_prune(struct graph *g, bool (*prune)(struct edge *e, void *arg),
 		void *_arg);
 int graph_minseg(struct graph *g, struct arraylist *path,
 		 struct arraylist *res);
+void graph_cache_dijkstra(struct graph *g);
 
 static inline void graph_finalize(struct graph *g)
 {
